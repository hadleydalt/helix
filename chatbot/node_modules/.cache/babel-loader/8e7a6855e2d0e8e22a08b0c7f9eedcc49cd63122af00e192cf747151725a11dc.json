{"ast":null,"code":"var _jsxFileName = \"/Users/hadleydalton/Desktop/Desktop/sellscale_agentic_hr/chatbot/src/Chatbot.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef } from \"react\";\nimport axios from \"axios\";\nimport \"./Chatbot.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Chatbot = () => {\n  _s();\n  const [userInput, setUserInput] = useState(\"\");\n  const [messages, setMessages] = useState([]);\n  const [isStreaming, setIsStreaming] = useState(false);\n  const userId = \"user123\"; // Ideally, this would be dynamic for real users\n  const abortControllerRef = useRef(null);\n  const resetChat = async () => {\n    setMessages([]); // Clear messages on frontend\n\n    try {\n      await axios.post(\"http://127.0.0.1:5000/reset\", {\n        user_id: userId\n      });\n    } catch (error) {\n      console.error(\"Error resetting chat:\", error);\n    }\n  };\n  const sendMessage = async () => {\n    if (!userInput || isStreaming) return;\n    const newMessages = [...messages, {\n      role: \"user\",\n      content: userInput,\n      type: \"normal\"\n    }];\n    setMessages(newMessages);\n    setUserInput(\"\");\n    setIsStreaming(true);\n\n    // Add an empty assistant message that we'll update as we receive chunks\n    setMessages(prev => [...prev, {\n      role: \"assistant\",\n      content: \"\",\n      type: \"normal\"\n    }]);\n    try {\n      var _response$body;\n      // Create a new AbortController for this request\n      abortControllerRef.current = new AbortController();\n      const response = await fetch(\"http://127.0.0.1:5000/chat\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          user_id: userId,\n          message: userInput\n        }),\n        signal: abortControllerRef.current.signal\n      });\n      if (!response.ok) throw new Error('Network response was not ok');\n      const reader = (_response$body = response.body) === null || _response$body === void 0 ? void 0 : _response$body.getReader();\n      if (!reader) throw new Error('No reader available');\n      const decoder = new TextDecoder();\n      let assistantMessage = \"\";\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) break;\n        const chunk = decoder.decode(value);\n        const lines = chunk.split('\\n');\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const content = line.slice(6);\n            if (content === '[GENERATING_SEQUENCE]') {\n              // Replace the current message with a sequence generation message\n              setMessages(prev => {\n                const newMessages = [...prev];\n                newMessages[newMessages.length - 1] = {\n                  role: \"assistant\",\n                  content: \"Generating sequence...\",\n                  type: \"sequence\"\n                };\n                return newMessages;\n              });\n            } else {\n              assistantMessage += content;\n              setMessages(prev => {\n                const newMessages = [...prev];\n                newMessages[newMessages.length - 1] = {\n                  role: \"assistant\",\n                  content: assistantMessage,\n                  type: \"normal\"\n                };\n                return newMessages;\n              });\n            }\n          }\n        }\n      }\n    } catch (error) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        console.log('Request was aborted');\n      } else {\n        console.error(\"Error sending message:\", error);\n      }\n    } finally {\n      setIsStreaming(false);\n      abortControllerRef.current = null;\n    }\n  };\n  const handleKeyPress = e => {\n    if (e.key === \"Enter\") {\n      sendMessage();\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"chat-container\",\n      children: messages.map((msg, index) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: `message ${msg.role} ${msg.type === \"sequence\" ? \"sequence-message\" : \"\"}`,\n        children: [/*#__PURE__*/_jsxDEV(\"b\", {\n          children: msg.role === \"user\" ? \"You\" : \"Helix\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 127,\n          columnNumber: 13\n        }, this), msg.content]\n      }, index, true, {\n        fileName: _jsxFileName,\n        lineNumber: 123,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 121,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"input-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"text\",\n        value: userInput,\n        onChange: e => setUserInput(e.target.value),\n        onKeyPress: handleKeyPress,\n        placeholder: \"Type a message...\",\n        className: \"message-input\",\n        disabled: isStreaming\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 133,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: sendMessage,\n        className: \"send-button\",\n        disabled: isStreaming,\n        children: isStreaming ? \"...\" : \"Send\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 142,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 132,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 120,\n    columnNumber: 5\n  }, this);\n};\n_s(Chatbot, \"iu9gRAo2fsP6BgWdlJxS2kp0MAg=\");\n_c = Chatbot;\nexport default Chatbot;\nvar _c;\n$RefreshReg$(_c, \"Chatbot\");","map":{"version":3,"names":["React","useState","useRef","axios","jsxDEV","_jsxDEV","Chatbot","_s","userInput","setUserInput","messages","setMessages","isStreaming","setIsStreaming","userId","abortControllerRef","resetChat","post","user_id","error","console","sendMessage","newMessages","role","content","type","prev","_response$body","current","AbortController","response","fetch","method","headers","body","JSON","stringify","message","signal","ok","Error","reader","getReader","decoder","TextDecoder","assistantMessage","done","value","read","chunk","decode","lines","split","line","startsWith","slice","length","name","log","handleKeyPress","e","key","className","children","map","msg","index","fileName","_jsxFileName","lineNumber","columnNumber","onChange","target","onKeyPress","placeholder","disabled","onClick","_c","$RefreshReg$"],"sources":["/Users/hadleydalton/Desktop/Desktop/sellscale_agentic_hr/chatbot/src/Chatbot.tsx"],"sourcesContent":["import React, { useState, useRef } from \"react\";\nimport type { ChangeEvent, KeyboardEvent } from \"react\";\nimport axios from \"axios\";\nimport \"./Chatbot.css\";\n\ninterface Message {\n  role: \"user\" | \"assistant\";\n  content: string;\n  type?: \"sequence\" | \"normal\";\n}\n\nconst Chatbot: React.FC = () => {\n  const [userInput, setUserInput] = useState(\"\");\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isStreaming, setIsStreaming] = useState(false);\n  const userId = \"user123\"; // Ideally, this would be dynamic for real users\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const resetChat = async (): Promise<void> => {\n    setMessages([]); // Clear messages on frontend\n  \n    try {\n      await axios.post(\"http://127.0.0.1:5000/reset\", { user_id: userId });\n    } catch (error) {\n      console.error(\"Error resetting chat:\", error);\n    }\n  };\n\n  const sendMessage = async (): Promise<void> => {\n    if (!userInput || isStreaming) return;\n\n    const newMessages: Message[] = [...messages, { role: \"user\", content: userInput, type: \"normal\" }];\n    setMessages(newMessages);\n    setUserInput(\"\");\n    setIsStreaming(true);\n\n    // Add an empty assistant message that we'll update as we receive chunks\n    setMessages(prev => [...prev, { role: \"assistant\", content: \"\", type: \"normal\" }]);\n\n    try {\n      // Create a new AbortController for this request\n      abortControllerRef.current = new AbortController();\n\n      const response = await fetch(\"http://127.0.0.1:5000/chat\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          user_id: userId,\n          message: userInput\n        }),\n        signal: abortControllerRef.current.signal\n      });\n\n      if (!response.ok) throw new Error('Network response was not ok');\n\n      const reader = response.body?.getReader();\n      if (!reader) throw new Error('No reader available');\n\n      const decoder = new TextDecoder();\n      let assistantMessage = \"\";\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        const chunk = decoder.decode(value);\n        const lines = chunk.split('\\n');\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const content = line.slice(6);\n            \n            if (content === '[GENERATING_SEQUENCE]') {\n              // Replace the current message with a sequence generation message\n              setMessages(prev => {\n                const newMessages = [...prev];\n                newMessages[newMessages.length - 1] = {\n                  role: \"assistant\",\n                  content: \"Generating sequence...\",\n                  type: \"sequence\"\n                };\n                return newMessages;\n              });\n            } else {\n              assistantMessage += content;\n              setMessages(prev => {\n                const newMessages = [...prev];\n                newMessages[newMessages.length - 1] = {\n                  role: \"assistant\",\n                  content: assistantMessage,\n                  type: \"normal\"\n                };\n                return newMessages;\n              });\n            }\n          }\n        }\n      }\n    } catch (error) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        console.log('Request was aborted');\n      } else {\n        console.error(\"Error sending message:\", error);\n      }\n    } finally {\n      setIsStreaming(false);\n      abortControllerRef.current = null;\n    }\n  };\n\n  const handleKeyPress = (e: KeyboardEvent<HTMLInputElement>): void => {\n    if (e.key === \"Enter\") {\n      sendMessage();\n    }\n  };\n\n  return (\n    <div className=\"container\">\n      <div className=\"chat-container\">\n        {messages.map((msg, index) => (\n          <div \n            key={index} \n            className={`message ${msg.role} ${msg.type === \"sequence\" ? \"sequence-message\" : \"\"}`}\n          >\n            <b>{msg.role === \"user\" ? \"You\" : \"Helix\"}</b>\n            {msg.content}\n          </div>\n        ))}\n      </div>\n      <div className=\"input-container\">\n        <input\n          type=\"text\"\n          value={userInput}\n          onChange={(e: ChangeEvent<HTMLInputElement>) => setUserInput(e.target.value)}\n          onKeyPress={handleKeyPress}\n          placeholder=\"Type a message...\"\n          className=\"message-input\"\n          disabled={isStreaming}\n        />\n        <button \n          onClick={sendMessage}\n          className=\"send-button\"\n          disabled={isStreaming}\n        >\n          {isStreaming ? \"...\" : \"Send\"}\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default Chatbot; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}