{"ast":null,"code":"var _jsxFileName = \"/Users/hadleydalton/Desktop/Desktop/sellscale_agentic_hr/chatbot/src/Chatbot.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef } from \"react\";\nimport axios from \"axios\";\nimport \"./Chatbot.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Chatbot = () => {\n  _s();\n  const [userInput, setUserInput] = useState(\"\");\n  const [messages, setMessages] = useState([]);\n  const [isStreaming, setIsStreaming] = useState(false);\n  const userId = \"user123\"; // Ideally, this would be dynamic for real users\n  const abortControllerRef = useRef(null);\n  const resetChat = async () => {\n    setMessages([]); // Clear messages on frontend\n\n    try {\n      await axios.post(\"http://127.0.0.1:5000/reset\", {\n        user_id: userId\n      });\n    } catch (error) {\n      console.error(\"Error resetting chat:\", error);\n    }\n  };\n  const sendMessage = async () => {\n    if (!userInput || isStreaming) return;\n    const newMessages = [...messages, {\n      role: \"user\",\n      content: userInput\n    }];\n    setMessages(newMessages);\n    setUserInput(\"\");\n    setIsStreaming(true);\n\n    // Add an empty assistant message that we'll update as we receive chunks\n    setMessages(prev => [...prev, {\n      role: \"assistant\",\n      content: \"\"\n    }]);\n    try {\n      var _response$body;\n      // Create a new AbortController for this request\n      abortControllerRef.current = new AbortController();\n      const response = await fetch(\"http://127.0.0.1:5000/chat\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          user_id: userId,\n          message: userInput\n        }),\n        signal: abortControllerRef.current.signal\n      });\n      if (!response.ok) throw new Error('Network response was not ok');\n      const reader = (_response$body = response.body) === null || _response$body === void 0 ? void 0 : _response$body.getReader();\n      if (!reader) throw new Error('No reader available');\n      const decoder = new TextDecoder();\n      let assistantMessage = \"\";\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) break;\n        const chunk = decoder.decode(value);\n        const lines = chunk.split('\\n');\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const content = line.slice(6);\n            assistantMessage += content;\n            setMessages(prev => {\n              const newMessages = [...prev];\n              newMessages[newMessages.length - 1] = {\n                role: \"assistant\",\n                content: assistantMessage\n              };\n              return newMessages;\n            });\n          }\n        }\n      }\n    } catch (error) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        console.log('Request was aborted');\n      } else {\n        console.error(\"Error sending message:\", error);\n      }\n    } finally {\n      setIsStreaming(false);\n      abortControllerRef.current = null;\n    }\n  };\n  const handleKeyPress = e => {\n    if (e.key === \"Enter\") {\n      sendMessage();\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"chat-container\",\n      children: messages.map((msg, index) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: `message ${msg.role}`,\n        children: [/*#__PURE__*/_jsxDEV(\"b\", {\n          children: msg.role === \"user\" ? \"You\" : \"Helix\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 111,\n          columnNumber: 13\n        }, this), msg.content]\n      }, index, true, {\n        fileName: _jsxFileName,\n        lineNumber: 107,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 105,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"input-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"text\",\n        value: userInput,\n        onChange: e => setUserInput(e.target.value),\n        onKeyPress: handleKeyPress,\n        placeholder: \"Type a message...\",\n        className: \"message-input\",\n        disabled: isStreaming\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 117,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: sendMessage,\n        className: \"send-button\",\n        disabled: isStreaming,\n        children: isStreaming ? \"...\" : \"Send\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 126,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 116,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 104,\n    columnNumber: 5\n  }, this);\n};\n_s(Chatbot, \"iu9gRAo2fsP6BgWdlJxS2kp0MAg=\");\n_c = Chatbot;\nexport default Chatbot;\nvar _c;\n$RefreshReg$(_c, \"Chatbot\");","map":{"version":3,"names":["React","useState","useRef","axios","jsxDEV","_jsxDEV","Chatbot","_s","userInput","setUserInput","messages","setMessages","isStreaming","setIsStreaming","userId","abortControllerRef","resetChat","post","user_id","error","console","sendMessage","newMessages","role","content","prev","_response$body","current","AbortController","response","fetch","method","headers","body","JSON","stringify","message","signal","ok","Error","reader","getReader","decoder","TextDecoder","assistantMessage","done","value","read","chunk","decode","lines","split","line","startsWith","slice","length","name","log","handleKeyPress","e","key","className","children","map","msg","index","fileName","_jsxFileName","lineNumber","columnNumber","type","onChange","target","onKeyPress","placeholder","disabled","onClick","_c","$RefreshReg$"],"sources":["/Users/hadleydalton/Desktop/Desktop/sellscale_agentic_hr/chatbot/src/Chatbot.tsx"],"sourcesContent":["import React, { useState, useRef } from \"react\";\nimport type { ChangeEvent, KeyboardEvent } from \"react\";\nimport axios from \"axios\";\nimport \"./Chatbot.css\";\n\ninterface Message {\n  role: \"user\" | \"assistant\";\n  content: string;\n}\n\nconst Chatbot: React.FC = () => {\n  const [userInput, setUserInput] = useState(\"\");\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isStreaming, setIsStreaming] = useState(false);\n  const userId = \"user123\"; // Ideally, this would be dynamic for real users\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const resetChat = async (): Promise<void> => {\n    setMessages([]); // Clear messages on frontend\n  \n    try {\n      await axios.post(\"http://127.0.0.1:5000/reset\", { user_id: userId });\n    } catch (error) {\n      console.error(\"Error resetting chat:\", error);\n    }\n  };\n\n  const sendMessage = async (): Promise<void> => {\n    if (!userInput || isStreaming) return;\n\n    const newMessages: Message[] = [...messages, { role: \"user\", content: userInput }];\n    setMessages(newMessages);\n    setUserInput(\"\");\n    setIsStreaming(true);\n\n    // Add an empty assistant message that we'll update as we receive chunks\n    setMessages(prev => [...prev, { role: \"assistant\", content: \"\" }]);\n\n    try {\n      // Create a new AbortController for this request\n      abortControllerRef.current = new AbortController();\n\n      const response = await fetch(\"http://127.0.0.1:5000/chat\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          user_id: userId,\n          message: userInput\n        }),\n        signal: abortControllerRef.current.signal\n      });\n\n      if (!response.ok) throw new Error('Network response was not ok');\n\n      const reader = response.body?.getReader();\n      if (!reader) throw new Error('No reader available');\n\n      const decoder = new TextDecoder();\n      let assistantMessage = \"\";\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        const chunk = decoder.decode(value);\n        const lines = chunk.split('\\n');\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const content = line.slice(6);\n            assistantMessage += content;\n            setMessages(prev => {\n              const newMessages = [...prev];\n              newMessages[newMessages.length - 1] = {\n                role: \"assistant\",\n                content: assistantMessage\n              };\n              return newMessages;\n            });\n          }\n        }\n      }\n    } catch (error) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        console.log('Request was aborted');\n      } else {\n        console.error(\"Error sending message:\", error);\n      }\n    } finally {\n      setIsStreaming(false);\n      abortControllerRef.current = null;\n    }\n  };\n\n  const handleKeyPress = (e: KeyboardEvent<HTMLInputElement>): void => {\n    if (e.key === \"Enter\") {\n      sendMessage();\n    }\n  };\n\n  return (\n    <div className=\"container\">\n      <div className=\"chat-container\">\n        {messages.map((msg, index) => (\n          <div \n            key={index} \n            className={`message ${msg.role}`}\n          >\n            <b>{msg.role === \"user\" ? \"You\" : \"Helix\"}</b>\n            {msg.content}\n          </div>\n        ))}\n      </div>\n      <div className=\"input-container\">\n        <input\n          type=\"text\"\n          value={userInput}\n          onChange={(e: ChangeEvent<HTMLInputElement>) => setUserInput(e.target.value)}\n          onKeyPress={handleKeyPress}\n          placeholder=\"Type a message...\"\n          className=\"message-input\"\n          disabled={isStreaming}\n        />\n        <button \n          onClick={sendMessage}\n          className=\"send-button\"\n          disabled={isStreaming}\n        >\n          {isStreaming ? \"...\" : \"Send\"}\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default Chatbot; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}